#!/bin/bash
#
# Kubernetes Namespace Backup Script for Kubespray
# Generated automatically - do not edit manually
# {{ ansible_managed }}
#
# Cron example: {{ namespace_backup_schedule }} {{ backup_path }}/scripts/backup-k8s-namespaces.sh > /dev/null 2>&1

set -euo pipefail

# Configuration
DATE=$(date '+%Y-%m-%d')
BACKUP_DIR_PFX="json-"
BACKUPROOT="{{ k8s_backup_root }}"
BACKUPDIR="${BACKUPROOT}/${BACKUP_DIR_PFX}${DATE}"
KUBECTL_BIN="{{ bin_dir }}/kubectl"
KUBECONFIG="/etc/kubernetes/admin.conf"

# Retention days
RETENTION_DAYS="{{ k8s_backup_retention_days }}"

# Excluded namespaces
EXCLUDE_NS="{{ exclude_ns_string }}"

# Check if kubectl exists
if [ ! -f "$KUBECTL_BIN" ]; then
    echo "ERROR: kubectl not found at $KUBECTL_BIN"
    exit 1
fi

# Check if kubeconfig exists
if [ ! -f "$KUBECONFIG" ]; then
    echo "ERROR: kubeconfig not found at $KUBECONFIG"
    exit 1
fi

export KUBECONFIG="$KUBECONFIG"

# Create backup directory
if [ ! -d "$BACKUPDIR" ]; then
    mkdir -p "$BACKUPDIR"
    chmod 700 "$BACKUPDIR"
fi

echo "[$(date '+%Y-%m-%d %H:%M:%S')] Starting Kubernetes namespace backup: $BACKUPDIR"

# Get namespaced resources (exclude dynamic/ephemeral resources)
K8S_NS_RESOURCES=$("$KUBECTL_BIN" api-resources --verbs=list --namespaced -o name 2>/dev/null | grep -v -E "(endpoints|events|leases|controllerrevisions.apps|daemonsets.apps|metrics|pods|pods.metrics.k8s.io|podtemplates|replicasets.apps|replicasets|ingresses.extensions)" || true)

# Get cluster-wide resources (exclude system resources)
K8S_CLUSTER_RESOURCES=$("$KUBECTL_BIN" api-resources --verbs=list --namespaced=false -o name 2>/dev/null | grep -v -E "componentstatuses|nodes|nodes.metrics.k8s.io" || true)

# Backup cluster level objects
if [ -n "$K8S_CLUSTER_RESOURCES" ]; then
    echo "$K8S_CLUSTER_RESOURCES" | while read -r resource; do
        if [ -n "$resource" ]; then
            output=$("$KUBECTL_BIN" get --show-kind --ignore-not-found "$resource" -o json 2>/dev/null | jq -r 'del(
                .items[].metadata.annotations."kubectl.kubernetes.io/last-applied-configuration",
                .items[].metadata.creationTimestamp,
                .items[].metadata.generation,
                .items[].metadata.resourceVersion,
                .items[].metadata.selfLink,
                .items[].metadata.uid,
                .items[].spec.clusterIP,
                .items[].status,
                .items[].metadata.managedFields
            )' 2>/dev/null || echo "{}")
            
            if [ "$output" != "{}" ] && [ -n "$output" ]; then
                resource_file=$(echo "$resource" | tr '/' '_')
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] Backing up $resource to file $BACKUPDIR/$resource_file.json"
                echo "$output" > "$BACKUPDIR/$resource_file.json"
            fi
        fi
    done
fi

# Backup namespaced objects
if [ -n "$K8S_NS_RESOURCES" ]; then
    "$KUBECTL_BIN" get ns -o name 2>/dev/null | sed 's:namespace/::g' | while read -r ns; do
        # Skip excluded namespaces
        if echo "$EXCLUDE_NS" | grep -qw "$ns"; then
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Skipping excluded namespace: $ns"
            continue
        fi
        
        mkdir -p "$BACKUPDIR/namespaces/$ns"
        
        echo "$K8S_NS_RESOURCES" | while read -r resource; do
            if [ -n "$resource" ]; then
                output=$("$KUBECTL_BIN" get --show-kind --ignore-not-found "$resource" -o json -n "$ns" 2>/dev/null | jq -r 'del(
                    .items[].metadata.annotations."kubectl.kubernetes.io/last-applied-configuration",
                    .items[].metadata.creationTimestamp,
                    .items[].metadata.generation,
                    .items[].metadata.resourceVersion,
                    .items[].metadata.selfLink,
                    .items[].metadata.uid,
                    .items[].spec.clusterIP,
                    .items[].status,
                    .items[].metadata.managedFields
                )' 2>/dev/null || echo "{}")
                
                if [ "$output" != "{}" ] && [ -n "$output" ]; then
                    resource_file=$(echo "$resource" | tr '/' '_')
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Backing up $ns $resource to file $BACKUPDIR/namespaces/$ns/$resource_file.json"
                    echo "$output" > "$BACKUPDIR/namespaces/$ns/$resource_file.json"
                fi
            fi
        done
    done
fi

# Create compressed archive
echo "[$(date '+%Y-%m-%d %H:%M:%S')] Creating compressed archive..."
tar czf "${BACKUPDIR}.tar.gz" -C "$BACKUPROOT" "${BACKUP_DIR_PFX}${DATE}" 2>/dev/null || true
rm -rf "$BACKUPDIR"

echo "[$(date '+%Y-%m-%d %H:%M:%S')] Backup completed: ${BACKUPDIR}.tar.gz"

# Cleanup old backups (keep only RETENTION_DAYS)
if [ $(ls "${BACKUPROOT}/${BACKUP_DIR_PFX}"* 2>/dev/null | wc -l) -gt "$RETENTION_DAYS" ]; then
    find "$BACKUPROOT" -name "${BACKUP_DIR_PFX}*" -mtime +$((RETENTION_DAYS - 1)) -exec rm -f {} \;
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Cleaned up old backups (retention: $RETENTION_DAYS days)"
fi

exit 0

